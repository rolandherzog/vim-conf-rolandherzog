" Basic settings
" --------------
set backspace=indent,eol,start
set encoding=utf8
set showcmd

" Set color scheme
" see http://www.vi-improved.org/color_sampler_pack/
colorscheme papayawhip
colorscheme chela_light
colorscheme sienna

" Control the initial size of the vim or gvim window
set lines=50 columns=100

" Disable modelines due to security concerns, see http://www.guninski.com/vim1.html
set modelines=0

" Turn on line numbers
set number

" Set max # of tabs (default is 10)
set tabpagemax=100

" Set syntax highlighting on
syntax on

" Increase undolevels
set undolevels=1000

" Keep a long command history (default is 20)
set history=200

" Turn autoindent on
set autoindent

" How to show wrapped lines
set showbreak=>\
set showbreak=...

" Autocomplete like the bash
set wildmode=longest,list
set completeopt=longest,menuone

" Set scroll behavior
set scrolloff=3             " keep at least 3 lines above/below cursor
set scrolloff=100           " keep cursor vertically in the middle of the window 
set sidescrolloff=5         " keep at least 5 columns left/right of cursor

" Turn off the error beep, make it visual instead
set visualbell

" Watch for file changes outside of vim and reload
set autoread

" Do not automatically write on :next etc.
set noautowrite
set noautowriteall

" Get hostname for some specific actions below
" --------------------------------------------
let shellcmd = 'hostname'
let hostname = system(shellcmd)

" Set GUI options
" ---------------
set guioptions-=m
set guioptions-=T

" Set GUI font depending on whether external display is attached or not
" but on host arwen only, or always when vim's environments shows that
" it is running via SSH 
if has("gui_running")
	if hostname =~ '^arwen.*'
		let shellcmd = 'xrandr -q | grep "^HDMI1 disconnected"'
		let dummy = system(shellcmd)
		if v:shell_error == 0 || !empty($SSH_CONNECTION)
			set guifont=Monospace\ 14
		elseif hostname =~ '^mab202.*'
			set guifont=Monospace\ 12
		endif
	endif
endif

" Enable actions on file load
" ---------------------------
filetype plugin on           "invoke plugin for all filetypes
filetype indent on           "enables automatic indentation 

" Set search path
" ---------------
set path+=~/Work/Teaching/Exercises/**
set path+=~/Work/WWW/**
set path+=~/Work/Achievements/CV/**
let texpath = $TEXINPUTS
let texpath = substitute(texpath, ':', ',', 'g')
let texpath = substitute(texpath, '//', '/**', 'g')
let &path = &path . ',' . texpath
let bibpath = $BIBINPUTS
let bibpath = substitute(bibpath, ':', ',', 'g')
let bibpath = substitute(bibpath, '//', '/**', 'g')
let &path = &path . ',' . bibpath

" Expand search path to find easily FEniCS and cppmat header files 
" ----------------------------------------------------------------
let &path = &path . ',~/Work/Software/cppmat/src/cpp/**'
let shellcmd = 'dolfin-version'
let dolfin_version = system(shellcmd)
let dolfin_version = substitute(dolfin_version, "\\n", '', '')
if dolfin_version != ""
	" echo hostname
	" echo dolfin_version
	if hostname =~ '^romulus.*'
		let &path = &path . ',' . substitute('/usr/local/FEniCS/VERSION/src/dolfin-VERSION/dolfin/**', 'VERSION', dolfin_version, 'g')
	elseif hostname =~ '^arwen.*'
		let dolfin_src_dir = substitute('/tmp/dolfin-VERSION', 'VERSION', dolfin_version, 'g')
		" echo dolfin_src_dir
		if !isdirectory(dolfin_src_dir)
			let shellcmd = '~/bin/get_FEniCS_source'
			" echo shellcmd
			let dummy = system(shellcmd)
		endif
		let &path = &path . ',' . dolfin_src_dir . '/dolfin/**'
	endif
	" echo &path
endif
set suffixesadd=.h,.hpp


" Set statusline
" --------------
set statusline= 
set statusline+=%<\                       " cut at start 
set statusline+=%2*[%n%H%M%R%W]%*\        " flags 
set statusline+=%-40f\                    " path 
set statusline+=%=%1*%y%*%*\              " file type 
set statusline+=%10((%l,%c)%)\            " line and column 
set statusline+=%P                        " percentage of file 
set laststatus=2                          " always show statusline

" Set some search options
" -----------------------
set smartcase                " select smart case in search patterns 
set ignorecase               " must be set to make smartcase work
set hlsearch                 " enable search highlight
set showmatch                " show matching brackets while typing
set incsearch

" Set some diff options
" ---------------------
set diffopt=filler,iwhite

" Settings related to tab stops
" -----------------------------
set tabstop=2
set softtabstop=0            "
set noexpandtab              " 
set list                     " show tabs as CTRL-I
set listchars=tab:\|\        " what to show instead of a tab (CTRL-I)
set shiftwidth=2             " # of spaces to use for each step of (auto)indent

" Clear all mappings
mapclear

" Set local leader 
let maplocalleader=','

" Some key mappings in insert mode
" imap <M-k> <Up>
" imap <M-h> <Left>
" imap <M-j> <Down>
" imap <M-l> <Right>
" imap <M-d> (
" imap <M-f> )
imap <M-h> (
imap <M-l> )
imap <M-j> {
imap <M-k> }
imap <M-n> [
imap <M-m> ]
" imap IMAP ('<M-a>', '\added[RH]{<++>}<++>', "tex")
" imap IMAP ('<M-d>', '\deleted[RH]{<++>}<++>', "tex")
" imap IMAP ('<M-r>', '\replaced[RH]{<++>}{<++>}<++>', "tex")
" inoremap <M-a> \added[RH]{}
" inoremap <M-d> \deleted[RH]{}
" inoremap <M-r> \replaced[RH]{}{}
" imap <C-s> <C-o>:w<CR>
" imap <C-S-s> <C-o>:wall<CR>
inoremap <ESC> <ESC><Right>

" Some key mappings in normal mode
nmap <M-o> :tabnext<CR>
nmap <M-i> :tabNext<CR>
nmap <M-1> 1gt
nmap <M-2> 2gt
nmap <M-3> 3gt
nmap <M-4> 4gt
nmap <M-5> 5gt
nmap <M-6> 6gt
nmap <M-7> 7gt
nmap <M-8> 8gt
nmap <M-9> 9gt
nmap <C-x><C-f> :tabfind 
nmap <C-x><C-n> :tabnew 
nmap <C-s> :w<CR>
nmap <C-S-s> :wall<CR>
nmap <C-x><C-c> :quit<CR>
nmap <C-k> :bd<CR>
nmap Y y$
nmap <LocalLeader>nh :nohlsearch<CR>
nnoremap gf <C-w>gf 

" Settings related to the latex-suite
" -----------------------------------
" empty .tex files have 'latex' file type
let g:tex_flavor='latex'
" define which environments are of itemize type
let g:tex_itemize_env='itemize\|description\|enumerate\|thebibliography\|enumerateroman\|enumeratearabic\|algorithmic'
let g:tex_items='\\bibitem\|\\item\|\\STATE\|\\IF\|\\ELSE\|\\ELSIF\|\\ENDIF\|\\FOR\|\\FORALL\|\\ENDFOR\|\\WHILE\|\\ENDWHILE\|\\REPEAT\|\\UNTIL\|\\LOOP\|\\ENDLOOP\|\\REQUIRE\|\\ENSURE\|\\RETURN\|\\PRINT'
" do not extra indent continuation lines of an \item
" let g:tex_indent_items=1
" Turn of spell checking in tex comments (see syntax/tex.vim)
let g:tex_comment_nospell=1

" Settings related to the latex-suite
" -----------------------------------
function! s:insert_tex_header()
	normal! O\documentclass[english,framed_theorems]{numapde_preprint} 
	normal! j
endfunction
autocmd BufNewFile *.tex call <SID>insert_tex_header()

""" Enhanced Commentify
" ---------------------
" Nice indentation:     
let EnhCommentifyRespectIndent = 'yes'
let EnhCommentifyPretty = 'yes'       
let EnhCommentifyUseBlockIndent = 'yes'
" Use large comment blocks             
let EnhCommentifyMultiPartBlocks = 'yes'
" Own Bindings                          
let EnhCommentifyUserBindings = 'yes'   
" FÃ¼r Markierungen und sowas wie 3<C-C> im Normalmodus:
nmap <silent> <c-c> :MyEnhancedCommentify<CR>          
vmap <silent> <c-c> :MyEnhancedCommentify<CR>          
command! -range MyEnhancedCommentify call EnhancedCommentify('yes', 'first', <line1>, <line2>)

" Some useful macros
" ------------------
" \added[id=RH]{<<++>>}
let @a='i\added[id=RH]{<<++>>}'
" \added[...]{text} -> text
let @b='dt{ma%x`ax'
" \deleted[id=RH]{<<++>>}
let @d='i\deleted[id=RH]{<<++>>}'
" \deleted[...]{text} -> 
let @e='dt{daB'
" \replaced[id=RH]{<<++>>}{<<++>>}
let @d='i\replaced[id=RH]{<<++>>}{<<++>>}'
" \replaced[...]{text1}{text2} -> text1
let @s='dt{ma%xldaB`ax'

" Insert a '\langde{' before and '}\langen{}' after the selection
" ---------------------------------------------------------------
" Helper Function: Insert at position
function InsertAt(string, pos, insertstring)
	if a:pos <= 1
		return a:insertstring . a:string
	else
		return a:string[:(a:pos-1)] . a:insertstring . a:string[(a:pos):]
	endif
endfunction

function InsertLang()
	" Get the positions from the last (or current) selection
	let startpos = getpos("'<")
	let endpos = getpos("'>")
	" Modify the lines
	let endline = getline(endpos[1])
	let endline = InsertAt(endline, endpos[2], '}<<++>>\langen{<<++>>}')
	call setline(endpos[1], endline)
	let startline = getline(startpos[1])
	let startline = InsertAt(startline, startpos[2]-1, '\langde{')
	call setline(startpos[1], startline)
	" Set the cursor position
	if endpos[2] == 2147483647
		call setpos('.', [endpos[0], endpos[1], endpos[2], 0])
	else
		call setpos('.', [endpos[0], endpos[1], endpos[2]+18, 0])
	endif
endfunction

" Mapping: Insert the language commands and goto insert mode.
vmap <silent> gl <esc>:call InsertLang()<CR>i

" Define some abbreviations
iab <expr> dts strftime("%d.%m.%Y")


